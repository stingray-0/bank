#include <iostream>
#include <ctime>
#include <vector>
#include <unordered_map>
#include <chrono>
#include <fstream>
#include <filesystem>
#include <csignal>
#include <windows.h>
#include <atomic>
#include <thread>

namespace paths
{
    const std::filesystem::path backup_data = "backup_bank_data.txt";
    const std::filesystem::path temp_data = "temp_bank_data.txt";
    const std::filesystem::path data = "bank_data.txt";
}


class deposit
{
public:
    long long amount;
    int deposit_hour;
    time_t deposit_time;
    deposit(int m) : amount(m)
    {
        deposit_time = time(nullptr);
        tm* local_tm = localtime(&deposit_time);
        deposit_hour = local_tm->tm_hour;    
    }
    deposit(int m, time_t time, int hour) : amount(m), deposit_time(time), deposit_hour(hour){}
};

class user
{
private:
    std::string m_username;
    void cal_interest()
    {
        for (auto &depo : accounts) 
        {
            double interest_rate = 0;
            int periods = difftime(time(nullptr), depo.deposit_time) / 60 / 20;
            
            if (periods == 0) continue;
            if (depo.deposit_hour == 14) interest_rate = 1.2;
            else if (depo.deposit_hour == 15) interest_rate = 1.5;
            else interest_rate = 1.7;
            
            while (periods--) depo.amount *= interest_rate;
            depo.deposit_time = time(nullptr);
        }
        return;  
    }

public:
    std::vector<deposit> accounts;

    user() {};
    user(std::string new_user) : m_username(new_user) {}
    void new_deposit(int amount) 
    {
        accounts.push_back(deposit (amount));
    }

    void withdraw(int amount) 
    {   
        cal_interest();

        int total = 0;
        for (auto ac : accounts) total += ac.amount;
        if (total < amount) {
            std::cout << "You brokie\n";
            return;
        }
        if (total == amount) 
        {
            accounts.erase(accounts.begin(), accounts.end());
        }

        for (auto it = --accounts.end(); true ; ) 
        {

            if (it->amount > amount) 
            {
                it->amount -= amount;
                break;
            }
            else 
            {   
                amount -= it->amount;
                it = accounts.erase(it);

                if (it != accounts.begin()) --it;
            }
        }
    }

    void check() 
    {   
        cal_interest();
        
        int total = 0;
        for (auto ac : accounts) total += ac.amount;

        std::cout << total << '\n';
    }
};




void save(std::unordered_map<std::string, user> d)
{
    std::ofstream out_data(paths::temp_data);
    
    for (const auto& u : d)
    {
        out_data << u.first << ' ' << u.second.accounts.size() << '\n';
        for (deposit depo : u.second.accounts)
        {
            out_data << depo.amount << ' '<< depo.deposit_time << ' ' << depo.deposit_hour <<'\n';
        }
        out_data << '\n';
    }
    
    out_data.close();
}

void safe_save()
{
    if (!std::filesystem::exists(paths::temp_data))
    {
        std::cout << "No temp data\n";
        return;
    }
    
    std::error_code ec;
    std::filesystem::remove(paths::backup_data, ec);
    std::filesystem::rename(paths::data, paths::backup_data, ec);
    std::filesystem::rename(paths::temp_data, paths::data, ec);
    if (ec)
    {
        std::cout << "Ah shit....\n";
        std::cout << "Safe saving error: " << ec.message() << '\n';
    }
    else
    {
        std::cout << "Safe saving completed successfully!\n";
    }
}

void load(std::unordered_map<std::string, user>& d)
{
    
    if (std::filesystem::exists(paths::temp_data))
    {
        char copy;
        std::cout << "Do you want to copy temp_data to your current data? (Y/N)\n";
        std::cin >> copy;
        if (std::cin.fail() && std::cin.eof()) return;

        if (copy == 'Y')
        {
            std::cout << "Copying\n";
            std::filesystem::remove(paths::data);
            std::filesystem::copy(paths::temp_data, paths::data, std::filesystem::copy_options::overwrite_existing);        
        }
        
        std::filesystem::remove(paths::temp_data);
        return;
    }
    if (!std::filesystem::exists(paths::data) && !std::filesystem::exists(paths::backup_data))
    {
        std::cout << "Fresh start? Lemme create file for you real quick\n";
        std::ofstream out_data(paths::data);
        out_data.close();
        return;
    }
    if (!std::filesystem::exists(paths::data))
    {
        std::cout << "Lost data, restoring from backup\n";
        std::filesystem::copy_file(paths::backup_data, paths::data, std::filesystem::copy_options::overwrite_existing);
        return;
    }
    
    if (!std::filesystem::exists(paths::backup_data))
    {
        std::cout << "Seriously? You lost your backup data!\n";
        std::filesystem::copy_file(paths::data, paths::backup_data, std::filesystem::copy_options::overwrite_existing);
        return;
    }
    
    std::ifstream in_data(paths::data);
    if(!in_data)
    {
        std::cout << "Man! Where's the data!\n";
        return;
    }
    
    std::string name;
    int depo_count, amount, hour;
    time_t time;
    while (in_data >> name >> depo_count)
    {
        user u(name);
        for (int i = 0; i < depo_count; i++)
        {
            in_data >> amount >> time >> hour;
            deposit depo(amount, time, hour);
            u.accounts.push_back(depo);
        }
        d[name] = u;
    }
    
    if (in_data.eof())
    {
        std::cout << "Reached end of data\n";
    }
    else
    {
        std::cerr << "Error: Failed to read complete data\n";
    }
    
    in_data.close();
}

std::atomic_bool is_exiting = false;
std::atomic_bool has_saved = false;


BOOL WINAPI signal_handler(DWORD signal) 
{
    if (signal == CTRL_C_EVENT || signal == CTRL_CLOSE_EVENT || signal == CTRL_SHUTDOWN_EVENT) 
    {
        is_exiting = true;
        if (has_saved)
            std::_Exit(0);

        return TRUE;
    }

    return FALSE;
}
void can_save()
{
    while (!is_exiting)
        std::this_thread::sleep_for(std::chrono::milliseconds(1));

    if (!has_saved)
    {
        safe_save();
        has_saved = true;
    }

}

int main()
{
    SetConsoleCtrlHandler(signal_handler, TRUE);

    std::thread saver(can_save);
    saver.detach();

    std::unordered_map<std::string, user> data;
    
    load(data);
    while (true)
    {   
        if (is_exiting)
        {   
            std::cerr << "exiting...\n";
            save(data);
            while (!has_saved) std::this_thread::sleep_for(std::chrono::milliseconds(1));
            std::_Exit(0);
        }

        std::string acc = "";
        std::string action = "";
        int money = 0;
        
        std::cout << "Action (D/W/C/exit): ";
        if (is_exiting || !(std::cin >> action)) 
        {   

            std::cerr << "\nexiting...\n";
            save(data);
            while (!has_saved) std::this_thread::sleep_for(std::chrono::milliseconds(1));
            std::_Exit(0);
        }
        
        if (action == "exit")
        {
            std::cout << "Exiting program\n";
            save(data);
            safe_save();
            break;
        }

        

        std::cout << "Account name: ";
        if (is_exiting || !(std::cin >> acc)) 
        {   
            std::cerr << "\nexiting...\n";

            while (!has_saved) std::this_thread::sleep_for(std::chrono::milliseconds(1));
            std::_Exit(0);
        }


        if (data.try_emplace(acc, acc).second)
        {
            std::cout << "New account " << acc << " created!\n"; 
            save(data);
        }

        
        if (action == "D")
        {
            std::cout << "Deposit amount: ";
            std::cin >> money;

            if (std::cin.fail()) 
            {
                std::cerr << "Invalid input!\n";

                if (is_exiting && std::cin.eof()) 
                {
                    std::cerr << "exiting\n";
                    save(data);

                    while (!has_saved) std::this_thread::sleep_for(std::chrono::milliseconds(1));
                    std::_Exit(0);
                }
                std::cin.clear();
                
                continue;
            }

            if (money > 0)
            {
                data[acc].new_deposit(money);
                save(data);
            }
            else 
            {
                std::cout   <<"C'mon man what you trying to do?\n"
                            <<"Don't waste my time\n";
            }
        }
        else if (action == "W")
        {
            std::cout << "Withdraw amount: ";
            std::cin >> money;
            if (std::cin.fail()) 
            {
                std::cerr << "Invalid input!\n";

                if (is_exiting && std::cin.eof()) 
                {
                    std::cerr << "exiting\n";
                    save(data);

                    while (!has_saved) std::this_thread::sleep_for(std::chrono::milliseconds(1));
                    std::_Exit(0);
                }
                std::cin.clear();
                
                continue;
            }
            if (money > 0)
            {
                data[acc].withdraw(money);
                save(data);
            }
            else 
            {
                std::cout   <<"C'mon man what you trying to do?\n"
                            <<"Don't waste my time\n";
            }
        }
        else if (action == "C")
        {
            data[acc].check();
            save(data);
        }
        else
        {
            std::cout << "You're invalid action was eaten by a stingray\n";
        }
    }

    return 0;
}
